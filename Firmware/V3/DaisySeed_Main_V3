/////////////////////////////////////////////////////////
// h e l l o    n i c e   t o   s e e   u   t h e r e  //
/////////////////////////////////////////////////////////

// Threshold sweetspots :  FSR > ~8/12 | Orientation > ~2/5 | Accelerometer > ~15/20 | Tracking -> 1
// Frequency sweetspots = 65 / 100 / 150 / 200 / 300 

#include <Wire.h>
#include <Arduino.h>
#include <DaisyDuino.h>
#include <elapsedMillis.h>
#include <Adafruit_BNO08x.h>
#include <APA102.h>
#include <Adafruit_BNO08x.h>
//#include <SoftwareSerial.h>
#include <SD.h>
#include<SPI.h>

// --- Serial Buffers for RX/TX COM --- //
HardwareSerial Serial5(D5, D6);  // RX=D5, TX=D6

#define SERIAL_BUFFER_SIZE 128
char serial1Buffer[SERIAL_BUFFER_SIZE];
int serial1BufferIndex = 0;

char serial5Buffer[SERIAL_BUFFER_SIZE];
int serial5BufferIndex = 0;

// CS pin for SD
const int chipSelect = D7;

// Temporarily defining gui information for SD
#define PARAM_COUNT 9  // [Mode, Axis, Freq, Amp, Threshold, Vibe mode, Exp Mode, Rec State, Participant Number]
#define SD_WRITE_SPEED 20 // in ms | 50Hz
int recordState = 0;
int expMode;
int recMode;
int pId;
int vibeMode;

unsigned long currentRecMillis;
unsigned long previousRecMillis;
static unsigned long lastFlush = 0;

String expState = "";  //needs to be input from gui
String participant = ""; //needs to be input from gui
String vibration = "";  //needs to be input from gui
String fileName;

// track file creation
File dataFile;
bool fileCreated = false;

// --- FSR --- //
float smoothedPressureA, smoothedPressureB, smoothedPressureC = 0;
float alpha = 0.5;
int offset = 3;
int r_sensor0, r_sensor1, r_sensor2, r_sensor3, r_sensor4, r_sensor5;
int sensor0, sensor1, sensor2, sensor3, sensor4, sensor5;
float smoothBuffer0, smoothBuffer1, smoothBuffer2, smoothBuffer3, smoothBuffer4, smoothBuffer5, smoothBufferLin0, smoothBufferLin1, smoothBufferLin2, smoothBufferLin3, smoothBufferLin4, smoothBufferLin5, smoothBufferA, smoothBufferB, smoothBufferC;

// --- delta var --- //
long deltaCurrentA = 0.0;
long deltaCurrentB = 0.0;
long deltaCurrentC = 0.0;

long cumulativeDeltaA = 0;
long cumulativeDeltaB = 0;
long cumulativeDeltaC = 0;

double sensor_pressureA = 0.0;
double sensor_pressureB = 0.0;
double sensor_pressureC = 0.0;

double prev_sensor_pressureA = 0.0;
double prev_sensor_pressureB = 0.0;
double prev_sensor_pressureC = 0.0;

double delta_sensor_pressureA = 0.0;
double delta_sensor_pressureB = 0.0;
double delta_sensor_pressureC = 0.0;

double prev_imu_x = 0.0;
double prev_imu_y = 0.0;
double prev_imu_z = 0.0;

double delta_imu_x = 0.0;
double delta_imu_y = 0.0;
double delta_imu_z = 0.0;

// --- IMU --- //
#ifdef FAST_MODE
  // Top frequency is reported to be 1000Hz (but freq is somewhat variable)
  sh2_SensorId_t reportType = SH2_GYRO_INTEGRATED_RV;
  long reportIntervalUs = 2000;
#else
  // Top frequency is about 250Hz but this report is more accurate
  sh2_SensorId_t reportType = SH2_ARVR_STABILIZED_RV;
  long reportIntervalUs = 5000;
#endif

#define BNO08X_RESET -1
Adafruit_BNO08x  bno08x(BNO08X_RESET);
sh2_SensorValue_t sensorValue;

struct euler_t {
  float yaw;
  float pitch;
  float roll;
} ypr;

float imu_x, imu_y, imu_z;

// Variables to track angle for each axis
float prevAngle_x = 0, prevAngle_y = 0, prevAngle_z = 0;
float totalAngle_x = 0, totalAngle_y = 0, totalAngle_z = 0;
bool isFirstReading = true;  // Flag for the first reading

void quaternionToEuler(float qr, float qi, float qj, float qk, euler_t* ypr, bool degrees = false) {

    float sqr = sq(qr);
    float sqi = sq(qi);
    float sqj = sq(qj);
    float sqk = sq(qk);

    ypr->yaw = atan2(2.0 * (qi * qj + qk * qr), (sqi - sqj - sqk + sqr));
    ypr->pitch = asin(-2.0 * (qi * qk - qj * qr) / (sqi + sqj + sqk + sqr));
    ypr->roll = atan2(2.0 * (qj * qk + qi * qr), (-sqi - sqj + sqk + sqr));

    if (degrees) {
      ypr->yaw *= RAD_TO_DEG;
      ypr->pitch *= RAD_TO_DEG;
      ypr->roll *= RAD_TO_DEG;
    }
}

void quaternionToEulerRV(sh2_RotationVectorWAcc_t* rotational_vector, euler_t* ypr, bool degrees = false) {
    quaternionToEuler(rotational_vector->real, rotational_vector->i, rotational_vector->j, rotational_vector->k, ypr, degrees);
}

// ========== Variables to store acceleration, velocity, position ============ //

float ax = 0, ay = 0, az = 0;     // Acceleration in m/s²
float fax = 0, fay = 0, faz = 0;  // Filtered accel
float vx = 0, vy = 0, vz = 0;     // Velocity in m/s
float px = 0, py = 0, pz = 0;     // Position in meters

unsigned long lastTime = 0;       // To measure time between loops

// Filter parameters
float alpha_lp = 0.2;  // Low-pass filter smoothing factor (0.0–1.0)
float motionThreshold = 0.4;  // m/s² threshold to consider "not moving" 0.1-0.5

// ============ Audio/Haptics Flow signal variables ============ //
elapsedMicros pulseTimeUS = 0;

bool isVibrating = false;
bool shouldVibrate = false;

float deltaTresh = 15.0f;  // threshohold imu = 100,  fsr = ~10/30 
float ampValue = 0.0f;
float newAmpValue = 0.7f; // keep < 0.7 to prevent amp distortion
int freqValue = 150; // 70hz resonant freq for hap MKII - i prefer 100 or 150 or 200Hz, oher are too audible at my onion - base freq varifreq is  -/+ 20%
uint32_t signalDuration;

const int sampleRateHz = 100;
unsigned long sampleInterval = 1000 / sampleRateHz;  // Convert Hz to milliseconds
unsigned long lastSampleTime = 0;                    // Time of the last sample
elapsedMillis timer_imu_data = 0;
unsigned long prevTime = 0;
int variFreq = freqValue;

// --- Quantized trigger --- //
float rangeMin = 0.0f;           // or -180.0f, based on range
float rangeMax = 360.0f;         // or 180.0f
float triggerSpacing = 15.0f;    // degrees between each trigger (5-10 seems good)
int totalBins = (rangeMax - rangeMin) / triggerSpacing;

static int lastTriggerBinX = -1;  // store last triggered bin
static int lastTriggerBinY = -1;
static int lastTriggerBinZ = -1;

int espBins = 0;
// ================ DaisyVariables =============== //
DaisyHardware hw;
Svf filterLow;
Svf filterHigh;
size_t num_channels;
static Oscillator osc;

// ----------- SERIAL READ Variables ----------------- //
String inputString;
int input0 = 0, input1 = 0, input3 = 0, input4 = 0;
float input2;
bool espnowFlag = false;  // Flag triggered by ESPNOW messages
bool continuousFlag = false;

uint8_t espnowId;
float espnowFreq;
uint32_t espnowDur;
float espnowAmp;

// --------- Print control -------------- //
int printRefreshRate = 20 * 1000; // in microseconds - 20ms / ~50hz -
unsigned long previousPrintMicros = 0;
bool debugPrint = false;

// --- LEDS --- //
const uint8_t dataPin = 0;
const uint8_t clockPin = 1;
const uint16_t ledCount = 1;
float brightness = 0;
rgb_color colors[ledCount];

APA102<dataPin, clockPin> ledStrip;

// --- Mode management --- //
int modeValue = 1; // 0 -> OFF | 1 -> FSR | 2 -> Orientation | 3 -> Accelerometer | 4 -> ESP-NOW receive [...]
int axisValue = 0; //  0 = xyz | 1 = x | 2 = y | 3 = z | 4 = xy | 5 = yz | 6 = xz
// int ExperimentStateMode = 0; // 0 => we ignore data | 1 => Data goes to exploratory | 2 => data goes to confirmatory

// --- Callback --- //
void MyCallback(float** in, float** out, size_t size) {
  float sig;
  osc.SetAmp(ampValue);
  osc.SetFreq(freqValue);
  osc.SetWaveform(osc.WAVE_SIN);
  for (size_t i = 0; i < size; i++) {
    sig = osc.Process();
    out[0][i] = sig;
    out[1][i] = sig;
  }
}

// --- Setup --- //
void setup() {
  Serial.begin(115200); // debug serial
  Serial1.begin(9600);  // Use Serial1 for hardware UART -- GUI param
  Serial5.begin(9600); // Use Serial5 USART for Receiving data from the ESPNOW
  Wire.begin();

  float sample_rate;
  hw = DAISY.init(DAISY_SEED, AUDIO_SR_48K);
  num_channels = hw.num_channels;
  sample_rate = DAISY.get_samplerate();
  osc.Init(sample_rate);
  osc.SetFreq(freqValue);
  osc.SetAmp(0.0);
  osc.SetWaveform(osc.WAVE_SIN);
  DAISY.begin(MyCallback);
  prevTime = millis();  // Initialize time
  lastTime = micros();  // Save starting time
  delay(1000);

  Serial.println("Bonjour, Hola, Hello :-)");
  // see if the SD card is present and can be initialized:
  if (!SD.begin(chipSelect)) {
    Serial.println("Card failed, or not present");
    // don't do anything more:
    return;
  } else {
    Serial.println("Card initialised");
  }
  

  Serial.println("Adafruit BNO08x test!");
  // Try to initialize!
  if (!bno08x.begin_I2C()) {
    Serial.println("Failed to find BNO08x chip");
    while (1) { delay(10); }
  }
  Serial.println("BNO08x Found!");
  setReports(reportType, reportIntervalUs);

  delay(1000);
  //setReports();
}

// --- Loop --- //

void loop() {

  unsigned long currentPrintMicros = micros();
  currentRecMillis = millis();
  checkSerialInput();  // -- replace with actual check from gui -- //

  expState = String(expMode); // param from the weemos
  recordState = recMode;
  participant = String(pId);
  vibration = String(vibeMode);

  // If start recording pressed 
  if (recordState == 1 && !fileCreated) {
      fileName = expState + participant + vibration + ".csv";  
      dataFile = SD.open(fileName, FILE_WRITE);
      if (dataFile) {
          // Write header
          dataFile.println("Time,Sensor0,Sensor1,Sensor2,Sensor3,Sensor4,Sensor5");
          dataFile.flush(); // Make sure header is written
          fileCreated = true;
          Serial.println("Recording started, file created with header");
          Serial.print(expState); Serial.print(","); Serial.print(participant); Serial.print(","); Serial.println(vibration);
      } else {
          Serial.println("Error creating file!");
      }
  }

  //////////////////
  //   OFF MODE   //
  //////////////////

  if (modeValue == 0) {
    checkSerial1();
    ampValue = 0.0;
    // --- LED management --- // just blink light red
    brightness = 10 ; // 
    for(uint16_t i = 0; i < ledCount; i++) {
        colors[i] = rgb_color(100,0,0);
        ledStrip.write(colors, ledCount, brightness);
    }
  }

  //////////////////
  //   FSR MODE   //
  //////////////////

  if (modeValue == 1) {
    checkSerial1();
    bno08x.enableReport(SH2_ARVR_STABILIZED_RV, 0); // disable bno reports, prevent grounding issues

    // --- LED management --- //
    brightness = 10 ; // adjust brightness level depending of pressure
    for(uint16_t i = 0; i < ledCount; i++) {
        colors[i] = rgb_color(0, 100, 0); // adjust color depending on group pressed
        ledStrip.write(colors, ledCount, brightness);
      }

    // --- READ FSR VALUES --- // 

    // Raw Values reading

    r_sensor0 = analogRead(A0);
    r_sensor1 = analogRead(A1);
    r_sensor2 = analogRead(A2);
    r_sensor3 = analogRead(A3);
    r_sensor4 = analogRead(A4);
    r_sensor5 = analogRead(A5);

    checkSerialInput(); //replace with actual check from gui
    //if (currentRecMillis - previousRecMillis >= SD_WRITE_SPEED && recordState == 1){
    // when recording is active

    if (recordState == 1 && fileCreated) {
      if (!fileCreated) {
        dataFile = SD.open(fileName, FILE_WRITE); // open only once
        if (!dataFile) {
          Serial.println("Error opening file for writing!");
        } else {
          fileCreated = true;
        }
      }

      if (currentRecMillis - previousRecMillis >= SD_WRITE_SPEED && fileCreated) {
        // Write raw sensor readings as CSV
        dataFile.print(millis());
        dataFile.print(",");
        dataFile.print(r_sensor0);
        dataFile.print(",");
        dataFile.print(r_sensor1);
        dataFile.print(",");
        dataFile.print(r_sensor2);
        dataFile.print(",");
        dataFile.print(r_sensor3);
        dataFile.print(",");
        dataFile.print(r_sensor4);
        dataFile.print(",");
        dataFile.println(r_sensor5);
        // no flush here (flushing every loop create big latncy)

        if (millis() - lastFlush > 1000) {  // flush once per second
          dataFile.flush();
          Serial.println("woosh, data flushed!");
          lastFlush = millis();
        }
      }
    }

    // when recording stops
    if (recordState == 0 && fileCreated) {
      dataFile.flush();   // final save
      dataFile.close();
      fileCreated = false;
      Serial.println("Recording stopped");
    }

    sensor0 = smooth(r_sensor0, &smoothBuffer0, 0.6); // subtle smoothing before linearization, 0.6 is enough
    sensor1 = smooth(r_sensor1, &smoothBuffer1, 0.6);
    sensor2 = smooth(r_sensor2, &smoothBuffer2, 0.6);
    sensor3 = smooth(r_sensor3, &smoothBuffer3, 0.6);
    sensor4 = smooth(r_sensor4, &smoothBuffer4, 0.6);
    sensor5 = smooth(r_sensor5, &smoothBuffer5, 0.6);
    
    // --- Linearize FSR response --- //
    double linSensor0 = map(smooth(linearize(sensor0, 3), &smoothBufferLin0, 0.6), 0, 1024, 0, 360); // exponent 2-4 give good results, alpha of 0.4 - 0.5
    double linSensor1 = map(smooth(linearize(sensor1, 3), &smoothBufferLin1, 0.6), 0, 1024, 0, 360);
    double linSensor2 = map(smooth(linearize(sensor2, 3), &smoothBufferLin2, 0.6), 0, 1024, 0, 360);
    double linSensor3 = map(smooth(linearize(sensor3, 3), &smoothBufferLin3, 0.6), 0, 1024, 0, 360);
    double linSensor4 = map(smooth(linearize(sensor4, 3), &smoothBufferLin4, 0.6), 0, 1024, 0, 360);
    double linSensor5 = map(smooth(linearize(sensor5, 3), &smoothBufferLin5, 0.5), 0, 1024, 0, 360);

    // --- Group FSR --- //

    float groupA; // Top/Bot      || A0/A5
    float groupB; // East/West    || A2/A4
    float groupC; // North/South  || A1/A3

    if (axisValue == 0) {
    groupA = abs((linSensor0 + linSensor5) /2 - offset); // Top/Bot      || A0/A5
    groupB = abs((linSensor2 + linSensor4) /2 - offset); // East/West    || A2/A4
    groupC = abs((linSensor3 + linSensor1) /2 - offset); // North/South  || A1/A3
    }

    if (axisValue == 1) {
    groupA = abs((linSensor0 + linSensor5) /2 - offset);
    groupB = 0; 
    groupC = 0; 
    }

    if (axisValue == 2) {
    groupA = 0; 
    groupB = abs((linSensor2 + linSensor4) /2 - offset); 
    groupC = 0; 
    }

    if (axisValue == 3) {
    groupA = 0;
    groupB = 0;
    groupC = abs((linSensor3 + linSensor1) /2 - offset);
    }

    if (axisValue == 4) {
    groupA = abs((linSensor0 + linSensor5) /2 - offset);
    groupB = abs((linSensor2 + linSensor4) /2 - offset);
    groupC = 0;
    }

    if (axisValue == 5) {
    groupA = 0;
    groupB = abs((linSensor2 + linSensor4) /2 - offset);
    groupC = abs((linSensor3 + linSensor1) /2 - offset);
    }

    if (axisValue == 6) {
    groupA = abs((linSensor0 + linSensor5) /2 - offset);
    groupB = 0;
    groupC = abs((linSensor3 + linSensor1) /2 - offset);
    }

    if(groupA < 3){groupA = 3;} // ignore base noise
    if(groupB < 3){groupB = 3;}
    if(groupC < 3){groupC = 3;}
      
    sensor_pressureA = int(adaptiveSmooth(groupA, &smoothBufferA, 0.5)); // some additional adaptive smoothing here, 0.4 - 0.6
    sensor_pressureB = int(adaptiveSmooth(groupB, &smoothBufferB, 0.5));
    sensor_pressureC = int(adaptiveSmooth(groupC, &smoothBufferC, 0.5));

    // --- Delta Calculations --- //
    delta_sensor_pressureA = abs(sensor_pressureA - prev_sensor_pressureA);
    delta_sensor_pressureB = abs(sensor_pressureB - prev_sensor_pressureB);
    delta_sensor_pressureC = abs(sensor_pressureC - prev_sensor_pressureC);

    deltaCurrentA = delta_sensor_pressureA;
    deltaCurrentB = delta_sensor_pressureB;
    deltaCurrentC = delta_sensor_pressureC;

    cumulativeDeltaA += deltaCurrentA;
    cumulativeDeltaB += deltaCurrentB;
    cumulativeDeltaC += deltaCurrentC;

    prev_sensor_pressureA = sensor_pressureA;
    prev_sensor_pressureB = sensor_pressureB;
    prev_sensor_pressureC = sensor_pressureC;

    // --- Haptic triggers --- //
    generateQuantizedTrigger(sensor_pressureA, lastTriggerBinX);
    generateQuantizedTrigger(sensor_pressureB, lastTriggerBinY);
    generateQuantizedTrigger(sensor_pressureC, lastTriggerBinZ);

    GenerateGrain(freqValue, &shouldVibrate, &ampValue, newAmpValue);

    // --- Print --- //
    if (currentPrintMicros - previousPrintMicros >= printRefreshRate && debugPrint > 0) {
      Serial.print(modeValue);
      Serial.print(" ");
      Serial.print(axisValue);
      Serial.print(" ");
      Serial.print(freqValue);
      Serial.print(" ");
      Serial.print(newAmpValue);
      Serial.print(" ");
      Serial.print(triggerSpacing);
      Serial.print(" ");

      Serial.print((sensor0 + sensor5) / 2);
      Serial.print(" ");
      Serial.print((sensor2 + sensor4) / 2);
      Serial.print(" ");
      Serial.print((sensor1 + sensor3) / 2);
      Serial.print(" ");

      Serial.print(sensor_pressureA);
      Serial.print(" ");
      Serial.print(sensor_pressureB);
      Serial.print(" ");
      Serial.print(sensor_pressureC);
      Serial.print(" ");

      Serial.println();
      previousPrintMicros = currentPrintMicros;
    }

  delay(5); // smoll delay to limit jitter in FSR
  }

  //////////////////////////
  //   ORIENTATION MODE   //
  //////////////////////////

  if (modeValue == 2) {
    checkSerial1();

    // --- LED management --- //
    brightness = 10 ; //
    for(uint16_t i = 0; i < ledCount; i++) {
        colors[i] = rgb_color(0,0,100); // adjust color depending on angle
        ledStrip.write(colors, ledCount, brightness);
      }  

    // --- imu readings --- //
    bno08x.enableReport(SH2_ACCELEROMETER, 0); // block bno accel reports 
    bno08x.enableReport(SH2_ARVR_STABILIZED_RV, reportIntervalUs); // enable bno orientation reports

    if (bno08x.getSensorEvent(&sensorValue)) {
        
      quaternionToEulerRV(&sensorValue.un.arvrStabilizedRV, &ypr, true);

      imu_x = ypr.yaw;
      imu_y = ypr.pitch;
      imu_z = ypr.roll;

      imu_y = mapAngle((imu_y + 90) / 180); // everyon goes to [-180,180] range
      updateTotalAngles(imu_x, imu_y, imu_z); // unwrapping the angles
    }

    // --- Axis mode --- // 

    if (axisValue == 0) {
    }

    if (axisValue == 1) {
      imu_y = 0;
      imu_z = 0;
    }

    if (axisValue == 2) {
      imu_x = 0;
      imu_z = 0;
    }

    if (axisValue == 3) {
    imu_x = 0;
    imu_y = 0;
    }

    if (axisValue == 4) {
    imu_z = 0;
    }

    if (axisValue == 5) {
    imu_x = 0;
    }

    if (axisValue == 6) {
    imu_y = 0;
    }

    // --- Delta Calculations --- // obsolete with quantized trigger method
    delta_imu_x = abs(imu_x - prev_imu_x);
    delta_imu_y = abs(imu_y - prev_imu_y);
    delta_imu_z = abs(imu_z - prev_imu_z);

    deltaCurrentA = delta_imu_x;
    deltaCurrentB = delta_imu_y;
    deltaCurrentC = delta_imu_z;

    cumulativeDeltaA += deltaCurrentA;
    cumulativeDeltaB += deltaCurrentB;
    cumulativeDeltaC += deltaCurrentC;

    prev_imu_x = imu_x;
    prev_imu_y = imu_y;
    prev_imu_z = imu_z;

    // --- Serial print --- //
    if (currentPrintMicros - previousPrintMicros >= printRefreshRate && debugPrint > 0) {
      Serial.print(freqValue);
      Serial.print(" ");
      Serial.print(newAmpValue);
      Serial.print(" ");
      Serial.print(triggerSpacing);
      Serial.print(" ");

      Serial.print(imu_x);
      Serial.print(" ");
      Serial.print(imu_y);
      Serial.print(" ");
      Serial.print(imu_z);
      Serial.print(" ");

      Serial.print(cumulativeDeltaA);
      Serial.print(" ");
      Serial.print(cumulativeDeltaB);
      Serial.print(" ");
      Serial.print(cumulativeDeltaC);
      Serial.print(" ");

      Serial.println();
      previousPrintMicros = currentPrintMicros;
    }

    // --- Haptic triggers --- //

    generateQuantizedTrigger(imu_x, lastTriggerBinX);
    generateQuantizedTrigger(imu_y, lastTriggerBinY); 
    generateQuantizedTrigger(imu_z, lastTriggerBinZ); 

    GenerateGrain(freqValue, &shouldVibrate, &ampValue, newAmpValue);
    delay(5);
  }

  ////////////////////////////
  //   ACCELEROMETER MODE   //
  ////////////////////////////

  if (modeValue == 3) {
    checkSerial1();
    // --- LED management --- //
    brightness = 0;
    for(uint16_t i = 0; i < ledCount; i++) {
        colors[i] = rgb_color(abs(imu_x) * 2,abs(imu_y) * 2, abs(imu_z) * 2); // adjust color depending on angle
        ledStrip.write(colors, ledCount, brightness);
    } 

    // --- imu readings --- //
    bno08x.enableReport(SH2_ARVR_STABILIZED_RV, 0); // disable bno orient reports
    bno08x.enableReport(SH2_LINEAR_ACCELERATION, reportIntervalUs); // enable bno accel reports 

    if (bno08x.getSensorEvent(&sensorValue)) {
  
      if (sensorValue.sensorId == SH2_LINEAR_ACCELERATION) {
      imu_x = sensorValue.un.linearAcceleration.x;
      imu_y = sensorValue.un.linearAcceleration.y;
      imu_z = sensorValue.un.linearAcceleration.z;

      }
    }

    // --- Axis mode --- // 

    if (axisValue == 0) {
    }

    if (axisValue == 1) {
      imu_y = 0;
      imu_z = 0;
    }

    if (axisValue == 2) {
      imu_x = 0;
      imu_z = 0;
    }

    if (axisValue == 3) {
    imu_x = 0;
    imu_y = 0;
    }

    if (axisValue == 4) {
    imu_z = 0;
    }

    if (axisValue == 5) {
    imu_x = 0;
    }

    if (axisValue == 6) {
    imu_y = 0;
    }

    // --- Position Calculus --- //
    unsigned long now = micros();
    float dt = (now - lastTime) / 1e6; // Time passed in seconds
    lastTime = now;

    ax = imu_x;
    ay = imu_y;
    az = imu_z;

    fax = alpha_lp * ax + (1 - alpha_lp) * fax;
    fay = alpha_lp * ay + (1 - alpha_lp) * fay;
    faz = alpha_lp * az + (1 - alpha_lp) * faz;

    // Detect near-zero acceleration (zero-velocity update) ---
    float amag = sqrt(fax*fax + fay*fay + faz*faz);
    bool isStationary = amag < motionThreshold;

    if (isStationary) {
    vx = vy = vz = 0;  // Stop integration when not moving
    } else {

      // Integrate acceleration to update velocity
      vx += fax * dt;
      vy += fay * dt;
      vz += faz * dt;

      // Integrate velocity to update position
      px += (vx * dt) * 100;
      py += (vy * dt) * 100;
      pz += (vz * dt) * 100;

    }

    // --- Serial print --- //
    if (currentPrintMicros - previousPrintMicros >= printRefreshRate && debugPrint > 0) {
      Serial.print(freqValue);
      Serial.print(" ");
      Serial.print(newAmpValue);
      Serial.print(" ");
      Serial.print(triggerSpacing);
      Serial.print(" ");

      Serial.print(vx);
      Serial.print(" ");
      Serial.print(vy);
      Serial.print(" ");
      Serial.print(vz);
      Serial.print(" ");

      Serial.print(px);
      Serial.print(" ");
      Serial.print(py);
      Serial.print(" ");
      Serial.print(pz);

      Serial.println();
      previousPrintMicros = currentPrintMicros;
    }

    // --- Haptic triggers --- //
    
    generateQuantizedTrigger(px, lastTriggerBinX);
    generateQuantizedTrigger(py, lastTriggerBinY);
    generateQuantizedTrigger(pz, lastTriggerBinZ);

    GenerateGrain(freqValue, &shouldVibrate, &ampValue, newAmpValue);
    delay(1);
  }

  //////////////////////
  //   ESP NOW MODE   //
  //////////////////////

  if (modeValue == 4) {
    checkSerial1();
    checkSerial5();
    // --- LED management --- //
    brightness = 15;
    for(uint16_t i = 0; i < ledCount; i++) {
        colors[i] = rgb_color(0,100,220); // power ranger force bleu
        ledStrip.write(colors, ledCount, brightness);
    } 

    // --- imu readings --- //
    bno08x.enableReport(SH2_ARVR_STABILIZED_RV, 0); // disable bno orient reports
    bno08x.enableReport(SH2_LINEAR_ACCELERATION, 0); // disable bno accel reports 

    if(espnowFlag) {
      espBins += 1;
      espnowFlag = false;
      Serial.println("Bzzz, Bzzz, just vibing <3");
    }

    // --- Serial print --- //
    if (currentPrintMicros - previousPrintMicros >= printRefreshRate && debugPrint > 0) {
      Serial.print(freqValue);
      Serial.print(" ");
      Serial.print(newAmpValue);
      Serial.print(" ");
      Serial.print(triggerSpacing);
      Serial.print(" ");

      Serial.print(espnowFlag);
      Serial.print(" ");
      Serial.print(espBins);
      Serial.print(" ");

      Serial.println();
      previousPrintMicros = currentPrintMicros;
    }

    // --- Haptic triggers --- //
    
    generateQuantizedTrigger(espBins, lastTriggerBinX);

    GenerateGrain(freqValue, &shouldVibrate, &ampValue, newAmpValue);
    delay(1);
  }

    /////////////////////////////////////////////
   //   OTHER MODE 1 (continuous + TRACKING)  //
  /////////////////////////////////////////////

  if (modeValue == 5) {
    checkSerial1();
    checkSerial5();
    continuousTrig();
    // --- LED management --- //
    brightness = 15;
    for(uint16_t i = 0; i < ledCount; i++) {
        colors[i] = rgb_color(100,220,0); 
        ledStrip.write(colors, ledCount, brightness);
    } 

    // --- imu readings --- //
    bno08x.enableReport(SH2_ARVR_STABILIZED_RV, 0); // disable bno orient reports
    bno08x.enableReport(SH2_LINEAR_ACCELERATION, 0); // disable bno accel reports 

    if(continuousFlag) {
      //espBins += 1;
      espnowFlag = true;
      isVibrating = true;
      ampValue = 0.5;
      Serial.println("Bzzz, Bzzz, just vibing continously <3");
    }

    if(!continuousFlag) {
      //espBins += 1;
      espnowFlag = false;
      isVibrating = false;
      ampValue = 0.0;
      Serial.println("Bzzz, Bzzz, just not vibing continously <3");
    }

    // --- Serial print --- //
    if (currentPrintMicros - previousPrintMicros >= printRefreshRate && debugPrint > 0) {
      Serial.print(freqValue);
      Serial.print(" ");
      Serial.print(newAmpValue);
      Serial.print(" ");
      Serial.print(triggerSpacing);
      Serial.print(" ");

      Serial.print(espnowFlag);
      Serial.print(" ");
      Serial.print(espBins);
      Serial.print(" ");

      Serial.println();
      previousPrintMicros = currentPrintMicros;
    }

    // --- Haptic triggers --- //
    
    //generateQuantizedTrigger(espBins, lastTriggerBinX);
    //GenerateGrain(freqValue, &shouldVibrate, &ampValue, newAmpValue);
    
    delay(1);
  }
}
/////////////////////////////////////////
//     FUNCTIONS FOR GRAIN FEEDBACK    //
/////////////////////////////////////////

void GenerateGrain(float freq, bool* vibrateFlag, float* amplitude_value, float newAmpValue) {
  signalDuration = 1000 * 1000 / freqValue;  // in µs

  if (isVibrating && (pulseTimeUS >= signalDuration)) {
    StopPulse(amplitude_value);
  }

  if (*vibrateFlag == true) {
    if (isVibrating && (pulseTimeUS >= signalDuration)) {
      StopPulse(amplitude_value);
    }
    if(pulseTimeUS >=  signalDuration) {//random(signalDuration / 2, signalDuration * 2)) { // minimum of 1 cycle space between grains to prevent grain overlap (maybe can add a random factor here too)
      //variFreq = random(freq * 0.8, freq * 1.2);
      StartPulse(freqValue, amplitude_value, newAmpValue);
    *vibrateFlag = false;
    }
  } 
}

void StartPulse(float freq, float* ampValue, float newAmpVal) {
  *ampValue = float(random((newAmpVal*10) / 2 ,newAmpVal * 10) / 10.0); // adding a small random here to make grains feel more 'natural'
  //Serial.print("amp value = "); Serial.println(*ampValue);
  osc.Reset();
  pulseTimeUS = 0;
  isVibrating = true;
}

void StopPulse(float* ampValue) {
  osc.Reset();
  *ampValue = 0.0;
  pulseTimeUS = 0;
  isVibrating = false;
}

void generateTrigger(long* cumulativeDelta, float deltaTreshold) { // old delta method of trigger DEPRECATED
  if (*cumulativeDelta >= deltaTreshold) {
    shouldVibrate = true;
    *cumulativeDelta = 0.0;
  } 
}

void generateQuantizedTrigger(long imuAngle, int& lastTriggerBin) {
    // Normalize angle to rangeMin, rangeMax
    float angle = fmod((imuAngle - rangeMin + 360.0f), 360.0f) + rangeMin;
    
    // Calculate current bin
    int currentBin = (int)((angle - rangeMin) / triggerSpacing);

    // Trigger only if new bin is entered
    if (currentBin != lastTriggerBin) {
        shouldVibrate = true;
        lastTriggerBin = currentBin;
    }
}

//////////////////////////////////////////
//      FUNCTIONS FOR FSR SENSING       //
//////////////////////////////////////////

float adaptiveSmooth(float inputValue, float* buffer, float smoothCurve) {
  float smoothingFactor= (smoothCurve + 0.01) - (smoothCurve * (float(inputValue) / 1023));
  *buffer = (smoothingFactor * inputValue) + ((1 - smoothingFactor) * *buffer);
  //Serial.print("Adaptive smooth = ");Serial.println(smoothingFactor);
  return *buffer;
}

float smooth(float inputValue, float* buffer, float alphaValue){
  *buffer = alphaValue * inputValue + (1 - alphaValue) * *buffer;
  return *buffer;
}

double linearize(float inputValue, int exponent){
  double linearizedValue = pow(11, pow(inputValue / 1023.0, exponent));
  return (linearizedValue - 1) * 102.3;
}

//////////////////////////////////////////
//      FUNCTIONS FOR SERIAL READ       //
//////////////////////////////////////////

// Check if a string is a valid int
bool isNumber(String s) {
  s.trim();
  if (s.length() == 0) return false;
  for (int i = 0; i < s.length(); i++) {
    if (!isDigit(s[i]) && !(i == 0 && s[i] == '-')) return false;
  }
  return true;
}

// Check if a string is a valid float
bool isFloat(String s) {
  s.trim();
  if (s.length() == 0) return false;
  bool dotSeen = false;
  for (int i = 0; i < s.length(); i++) {
    if (s[i] == '.') {
      if (dotSeen) return false;
      dotSeen = true;
    } else if (!isDigit(s[i]) && !(i == 0 && s[i] == '-')) {
      return false;
    }
  }
  return true;
}

// Process commands from Serial1 (WebGUI)// add a ExperimentalModeState mode and start and stop to this one
// ExperimentantalModeState : Exploratory, Confirmatory
// RecordingState : Start Recording - 1 , Stop Recording - 0

void processSerial1Command(char* cmd) {
  // Only accept commands that start with "SET,"
  if (strncmp(cmd, "SET,", 4) != 0) return;

  // Copy everything after "SET," into a local buffer
  char localCopy[SERIAL_BUFFER_SIZE];
  strncpy(localCopy, cmd + 4, SERIAL_BUFFER_SIZE - 1);
  localCopy[SERIAL_BUFFER_SIZE - 1] = '\0';

  // Tokenise by commas
  char* tokens[PARAM_COUNT] = {nullptr};
  char* token = strtok(localCopy, ",");
  int i = 0;
  while (token != nullptr && i < PARAM_COUNT) {
    tokens[i++] = token;
    token = strtok(nullptr, ",");
  }

  // Must have exactly PARAM_COUNT parameters
  if (i != PARAM_COUNT) {
    Serial1.println("ERR");
    Serial.println("ERR sent");
    return;
  }

  // ===== Parse your parameters =====
  modeValue       = atoi(tokens[0]);   // int
  axisValue       = atoi(tokens[1]);
  freqValue       = atoi(tokens[2]);
  newAmpValue     = atof(tokens[3]);   // float
  if (newAmpValue < 0 || newAmpValue > 0.7) newAmpValue = 0.7;
  triggerSpacing  = atoi(tokens[4]);   // int
  vibeMode        = atoi(tokens[5]);
  expMode         = atoi(tokens[6]);
  recMode         = atoi(tokens[7]);
  pId             = atoi(tokens[8]);

  // ===== Acknowledge =====
  Serial1.println("ACK");
  Serial.println("ACK sent");
}

// Process ESP-NOW commands from Serial5
void processSerial5EspNowCommand(char* cmd) {
  // Format: ESPNOW,<id>,<freq>,<dur>,<amp>;
  char localCopy[SERIAL_BUFFER_SIZE];
  strncpy(localCopy, cmd + 7, SERIAL_BUFFER_SIZE - 1); // skip "ESPNOW,"
  localCopy[SERIAL_BUFFER_SIZE - 1] = '\0';

  // Split into tokens
  char* tokens[4] = {nullptr};
  char* token = strtok(localCopy, ",");
  int i = 0;
  while (token != nullptr && i < 4) {
    // Trim trailing junk
    int len = strlen(token);
    while (len > 0 && (token[len-1] == ';' || token[len-1] == '\r' || token[len-1] == '\n' || token[len-1] == ' ')) {
      token[--len] = '\0';
    }

    tokens[i++] = token;
    token = strtok(nullptr, ",");
  }

  if (i != 4) {
    Serial.println("Invalid ESPNOW format");
    return;
  }

  espnowId   = atol(tokens[0]);
  espnowFreq = atof(tokens[1]);
  espnowDur  = atol(tokens[2]);
  espnowAmp  = atof(tokens[3]);
  espnowFlag = true;

  Serial.printf("ESPNOW parsed -> Id: %ld, Freq: %.2f Hz, Dur: %ld us, Amp: %.2f\n",
                espnowId, espnowFreq, espnowDur, espnowAmp);
  Serial.println();
}

 //temporarily for serial
void checkSerialInput() {
  if (Serial.available() > 0) {
    char cmd = Serial.read();  // read one character
    if (cmd == 's') {          // start recording
      recordState = 1;
      Serial.println("Recording STARTED via Serial");
    } else if (cmd == 'x') {   // stop recording
      recordState = 0;
      Serial.println("Recording STOPPED via Serial");
    }
  }
}


void continuousTrig() {
  if (espnowDur == 0 && espnowAmp > 0) {
    continuousFlag = true;
  }
  if (espnowDur == 0 && espnowAmp == 0) {
    continuousFlag = false;
  }
}

// Check Serial1 for WebGUI commands
void checkSerial1() {
  while (Serial1.available()) {
    char c = Serial1.read();
    Serial.print(c);

    if (c == '\r' || c == '\n') continue;

    if (c != ';' && serial1BufferIndex < SERIAL_BUFFER_SIZE - 1) {
      serial1Buffer[serial1BufferIndex++] = c;
    } else if (c == ';') {
      serial1Buffer[serial1BufferIndex] = '\0';
      processSerial1Command(serial1Buffer);
      serial1BufferIndex = 0;
    } else if (serial1BufferIndex >= SERIAL_BUFFER_SIZE - 1) {
      serial1BufferIndex = 0;  // prevent overflow
    }
  }
}

// Check Serial5 for ESPNOW commands
void checkSerial5() {
  while (Serial5.available()) {
    char c = Serial5.read();
    Serial.print(c);

    if (c == '\r' || c == '\n') continue;

    if (c != ';' && serial5BufferIndex < SERIAL_BUFFER_SIZE - 1) {
      serial5Buffer[serial5BufferIndex++] = c;
    } else if (c == ';') {
      serial5Buffer[serial5BufferIndex] = '\0';

      if (strncmp(serial5Buffer, "ESPNOW", 6) == 0) {
        processSerial5EspNowCommand(serial5Buffer);
      } else {
        Serial.println("Unknown command on Serial5");
      }
      serial5BufferIndex = 0;
    } else if (serial5BufferIndex >= SERIAL_BUFFER_SIZE - 1) {
      serial5BufferIndex = 0; // prevent overflow
      }
  }
}

//////////////////////////////
//     FUNCTION FOR IMU     //
//////////////////////////////

void setReports(sh2_SensorId_t reportType, long report_interval) {
  Serial.println("Setting desired reports");
  if (! bno08x.enableReport(reportType, report_interval)) {
    Serial.println("Could not enable stabilized remote vector");
  }
}

void quaternionToEulerGI(sh2_GyroIntegratedRV_t* rotational_vector, euler_t* ypr, bool degrees = false) {
    quaternionToEuler(rotational_vector->real, rotational_vector->i, rotational_vector->j, rotational_vector->k, ypr, degrees);
}

float mapAngle(float input) {
  return fmap(input, -180.0, 180.0);
}

float toRad(float inputAngle) {
  return inputAngle * (PI / 180.0);
}

// Function to update all three axes
void updateTotalAngles(float current_x, float current_y, float current_z) {
  // Skip the first reading comparison, just initialize
  if (isFirstReading) {
    prevAngle_x = current_x;
    prevAngle_y = current_y;
    prevAngle_z = current_z;
    isFirstReading = false;
    return;
  }
  
  // Update X-axis
  float diff_x = current_x - prevAngle_x;
  if (diff_x > 180) diff_x -= 360;
  else if (diff_x < -180) diff_x += 360;
  totalAngle_x += diff_x;
  prevAngle_x = current_x;
  
  // Update Y-axis
  float diff_y = current_y - prevAngle_y;
  if (diff_y > 180) diff_y -= 360;
  else if (diff_y < -180) diff_y += 360;
  totalAngle_y += diff_y;
  prevAngle_y = current_y;
  
  // Update Z-axis
  float diff_z = current_z - prevAngle_z;
  if (diff_z > 180) diff_z -= 360;
  else if (diff_z < -180) diff_z += 360;
  totalAngle_z += diff_z;
  prevAngle_z = current_z;
  
  // Convert to radians if needed 
  float totalXRad = toRad(totalAngle_x);
  float totalYRad = toRad(totalAngle_y);
  float totalZRad = toRad(totalAngle_z);
}

//   s e e   u   c y b e r s p a c e   c o w b o y   //
